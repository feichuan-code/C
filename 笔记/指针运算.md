# 指针运算

如果有一个指针  *p，那么 p+1的结果是多少？

```c
#include<stdio.h>

int main(){
	char ac[] = {0,1,2,3,4,5,6};
	char *p = ac;
	printf("p = %p\n",p);
	printf("p+1 = %p\n",p+1); 
	int ai[] = {0,1,2,3,4,5,6};
	int *q = ai;
	printf("p = %p\n",q);
	printf("p+1 = %p\n",q+1); 
	
}
输出
    p = 0061fec1
	p+1 = 0061fec2
	p = 0061fea4
	p+1 = 0061fea8
    *p -> ac[0]
    *(p+1) -> ac[1]
```

**`sizeof(char) = 1,sizeof(int) = 4`** 当我们给一个指针去 +1 的时候 它不是在地址值上 +1而是在地址值上 `**+sizeof(指针类型)**`

## 1+1 = 2？

- 给一个指针 +1 表示要让指针指向下一个变量
  -  `int a[10]`
  - `int *p = a`
  - `*(p+1) == a[1]`
  - `*(p+n) == a[n]`

- 如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义

## 指针计算

- 这些算术运算可以对指针做
  - 给指针加，减一个整数（+,+=,-,-=)
  - 递增递减
  - 两个指针相减

### *p++

- 取出p所指的数据来，顺便把p移到下个位置
- *的优先级虽然高，但是没有++高
- 常用于数组类的连续空间操作
- 在某些CPU上，这可以被直接翻译成一条汇编指令

```c
	char ac[] = {0,1,2,3,4,5,6,};
	char *p = ac[0];
	int i;
	int ai[] = {0,1,2,3,4,5,6,-1};
	int *q = ai;
	int *q1 = &ai[6];
	for(i = 0;i<sizeof(ac)/sizeof(a[0]);i++){
        printf("%d\n",a[i]);
    }//这是以前我们遍历数组的方法
	//有了指针以后，由于数组是特殊的指针
	//所以可以用这种方式遍历数组
	while(*p != -1){
        printf("%d\n",*p++);
    }
```

### 指针比较

- **<，<=，==，>，>=，!=** 都可以对指针做
- 比较它们在内存中的地址
- 数组中的单元的地址是线性递增的

### 0地址

- 当然你的内存中有0地址，但0地址通常是个不能随便碰的地址
- 所以你的指针不应该具有0值
- 但可以用0地址表示特殊的事情
  - 返回的指针是无效的
  - 指针没有被真正初始（先初始化为0）
- NULL是一个预定定义的符号，表示0地址
  - 有点编译器不愿意用0来表示**0地址**

### 指针类型

- 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
- 但是指向不同类型的指针是不能直接互相赋值的
- 这是为了避免用错指针

#### 指针类型的转换

- void* 表示不知道指向什么东西的指针
  - 计算时与 char* 相同（但不相通）
- 指针也可以转换类型
  - `int *p = &i; void*q = (void)*p`
- 但并没有改变p说指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量
  - **我不把你当人拉，我认为你就是一只狗拉**

## 指针可以用来做什么

- 需要传入较大的数据时用作参数
- 传入数组后对数组做操作
- 函数返回不止一个结果
  - 需要用函数来修改不止一个变量
- 动态申请的内存





